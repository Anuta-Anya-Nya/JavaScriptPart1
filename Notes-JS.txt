bJS - язык программирования, добавляет интерактив на страницу и взаимодействие с пользователем 
БЕЗ СТРОГОЙ ТИПИЗАЦИИ

программы, содержащие движок для выполнения JS:
веб-браузер+
Среды выполнения:
    Node.js (бэкекнд - серверное программирование) серверые возможности с Ubuntu
    Deno
    Electron + windows
Другое ПО где есть интерпритатор или компилятор JS кода 

Стандарты JS - ECMA International выработали ES5 в 2015 году и далее ES6 и далее 
---------------------------------------------
Переменные и области видимости 
let изменяемое значение
const - значение изменит нельзя - пишем капсом
var - старый способ, проблемы с областями видисости (не использовать! устаревший стандарт) - видна везде, ограничивается ТОЛЬУО блоком функции
Область видимости - участок кода, короты может обратииться к переменной и получить из мее значение
    локальная переменная
    глобальная переменная

Var может всплыть где угодно, для нее не существует областей видимости кроме боока функции. можно обьявить в конце кода, использовать в начале. с let const так не получится

if (3 > 1 ){ let a =5;} 
console.log(a) // error a is not defined - a создается let только в if 
if (3 > 1 ){ var b =5;} 
console.log(b) // 5 var создает везде

${переменная}
ОБратными кавычками
`вывести в консоль строку переменную: ${переменная} `
$_ спецсимволы в переменных разрешены
\n символ переноса строки
\ простой перенос строки в редакторе

Всплытие переменной(поднятие, hoisting) - механизм в js, в котором переменные и функции обьявленные как function declaration передвигаются вверх своей области видимостиперед тем как код будет выполнен 
    присвоение значений переменным юудет в тах же местах в коде, где они и были написаны
   - переменная обьявленная через var. обьявление всплывает, но присвоение остается на месте
   - let не всплывает как var 
   - в теле функции всплытие ограничивается телом функции (поэтому var ограничивается только функцией в плане глобальной зоны видимости )

---------------------------------------------------------------------
Подключить можно в HEAD (но нельзя). 
страница грузится сверху вниз, поэтому скрипт пишем в самом внизу перед закрывающим </body>:
   1. <script>
        let countButton = 0;
    </script>
    2.<script src="main.js"></script> - старый способ
    3. в теге head: грузятся параллельно с построением страницы
        <script async src="main1.js"></script> запустится когда загрухится, (плох потому что не знаешь когда загрузится и выполнится)
        <script defer src="main2.js"></script> запустится только тогда когда все теги созданным В ПРИОРИТЕТЕ
---------------------------------------------------------------------
ТИПЫ данных
string строка
number число
    NaN - (не число при ошибке вычисилений), арифметически ничего не сделать ("привет" * 10 = NaN)
    Infinity, -Infinity бесконечность - деление на 0 и на -0
boolean булево значение
undefined - спец тип данных - присваивается вновь созданным, но не инициализированным переменным 
object обьект - хранит набор данных, к полям(свойствам) обращается через . или ключ в квадратных скобках
    array - упорядочный список элементов
    function 
null - спец значение, используется в основном с обьектами, что в переменной нет обьекта 
symbol - новый тип данных, создает уникальные ключи для свойст обьектов
BigInt большое число больше 2**53 - для сложных расчетов, в конце литера n 

typeof переменная - тип данных 
typeof null = object - баг
 
Перевод строки в число:
+srt унарный плюс получим Nan если не число или число с буквами
Number(str) функция конструктор для чисел
Number.parseInt(str) собирает число из строки посимвольно (str=64.3regb5) получим 64
Number.parseFloat(str) получим 64.3

контеканация:
если есть хоть одна строка с +, то это контеканация
если слева и справа число, то это сложение

------------------------------------------------------------------------
switch()
case
default

тернарный оператор ? для легких if
console.log(
    goodCount > 0 ? 'в корзине есть товары' : 'корзина пуста'
);
----------------------------------------------------------------
ЦИКЛЫ 
повторяемое действие до наступление каких-то условий
1.инициализация переменных в начале цикла
2.проверка условия выхода на каждой итерации (до или после)
3. исполнение тела цикла на каждой итерации
4. обновление счетчика итерации

while(условие){тело}

do {
}while(условие)

for(let i=0; i<count; i++){}


for(const i in ...) переберет ключи 
for(const val of ...) переберет знаения в массиве(итера)
arr.forEach(функция) - выполняет функцию для каждого элемента 
arr.forEach((value, index, arr) => {тело стрелочной функции});



-------------------------------------------------------------------------
ФУНКЦИИ

function sayPrice(){
} после стандартного обьявления функции не стявятся ; - видна везде, обьявляется внизу function declaration
const fun2 = function (){}; вызывается только после обявляения function expression ставятся ;
Стрелочные функции:
const fn3 = () => {
    console.log(123);
};
const fn3 = () => console.log(123);

ФУНКЦИИ 
именнованные(присваивается имя) декларативный подход - обьявление через function nameFunc(параметры) 
анонимные function(праметр)

функциональное выражение const getMax = (numbers) => {}
стрелочные - возвращают значение
если 1 значение то скобки можно урбать let foo = number => { return number + 1;}
если совсем нет параметров ставятся скобки let foo = () => {}
если 1 действие, фигурные скобки и return можно убрать lef foo = number => number +1;
параметр по умолчанию let foo = (param = 5) => {}
если действие одно, {} не ставятся, но автоматом значит появляется return
если фигурные скобки стоят, return не ставится автоматом 

параметр - при создании функции
аргумент - передаем функции 

старый вариант const foo = function(a, b) {return a+b}
новый const foo = (a, b) => a + b;

области видимости
    локальная 
    глобальная

если переменная обьявлена без ключевого слова, она в глобальной области видимости. даже если в теле функции. область видимости windows
если переменная обьявлена с let то область видимости не window, a scriptSEO or Search Engine Optimization is the technique used to optimize your website for better rankings on search engines such as Google, Bing etc.


если передается в функцию аргументов больше, чем задумано
function hello(name, ...other){
    console.log('hello' + name);
    console.log(other); \\ other это массив переданных аргументов
}

let num=5;
function f(num){ // у функции создается СВОЯ переменная num, в нее копируется значение 5.
    num=10 // у локальной переменной значение становится 10, при завершении функции она стирается
}
console.log(num) // 5. т.к. переменная не изменилась

const obj = {num=5}; //создается обьект, ССЫЛКА на него записывается в переменную obj
function f(obj){ //в функцию передается ССЫЛКА на обьект (обьекты так не копируются, копируются только ссылки на ячейку памяти с обьектом)
    obj.num=10; //по ссылке ИЗМЕНЯЕТСЯ свойство в обьекте
}
console.log(obj) // 10, при завершении функции свойство ИЗМЕНЕНО



----------------------------------------------------------------------------------
Приведение типов:
Дают false:
""
0. -0, Nan
null, undefined
false

Инкремент - увеличение операнда на установленный фиксированный шаг а++
Декремент - уменьшение операнда на установленный фиксированный шаг а--
контеканация - сложение строк 
------------------------------------------------------
МАССИВЫ
упорядоченный список элементов 
при простом копировании массива в впеременную, копируется ССЫЛКА на масси, те изменение второй переменной влечет изменение исходного массива 
const array = [];

Перечислимые/неперечислимые свойства используемые при итерировании массива или обьекта 
    length - при итерировании не появляется
console.log(arr.propertyIsEnumerable('length')) - узнаем является ли перечислимым свойство //false 

forOF:
for(let value of array){
    console.log(value)//перебор значений массива
}

array.push(элемент); добавить в конец массива и возвращает новую длину массива
array.pop() - удаляет и возвращает последний элемент
string.split('разделитель') - разбивает строку и записывает в массив 
array.join('разделитель') - склеивает массив в строку с нужным разделителем 
array.slice() - возвращает полную копию массива, не ссылку
array.slice(0,2) - копирует с 0 индекса до 2(не включая) 
array.splice(с какого индекса удалить [, сколько элементов удалить, что добавить, ...]) удаляет сколько хочешь элементов и заменяет на другиею возвращает удаленные
array.indexOf(значение) - возвращает true или false если есть такое значение 
array.shift() - удаляет первый элемент из массива и возвращает его значение, изменяет длину массива 
array.unshift() - добавляет элемент в начало и возвращает новую длину массива
array.filter(функция фильтра - коллбек функция возвращает true/false) - записывает значения, которым вернулось true 
array.find() - возвращает значение первого найденного в массиве элемента, удовлетворяющего условию callback функции или возращает undefined
       const lessThan50 = prices.filter(function(element){ return element < 50};) - приходит каждый элемент в колбек функцию 
array.includes(значение) определяет содержит ли массив определенный элемент, возвращая true-false 
array.map(function) - метод применяет к каждому элементу функцию и формирует новый массив
        const numsPlus10 = nums.map(function(num){return num +10});
array.sort() -  на месте сортирует массив и модифицирует исходный. по умолчанию - по юникоду
    array.sort([compareFunction])
    function compare(a,b){
        if(a<b по некоторому критирию сортировки) return -1;
        if(a>b...)return 1;
        return 0; //усли равны 
    }
------------------------------------------------------
ОБЪЕКТЫ

o1 ={}; в переменную записывается ссылка на ячейку памяти где хранится обьект 
o2 ={}; уже другая ссылка
o1 === o2; false - ссылки на 2 обьекта не равны
если куда то передаем обьект, то передаем на сам обьект, а его ссылку

console.log(Object.getOwnPropertyNames(array)) - показывает список собственных свойств, не прототипа 

forIn:
for (let property in obj){
    console.log(property) //вывод ключей(имя свойств)
}
for (let property in obj){
    console.log(obj[property]) //вывод значений
}

Object.assign() - поверхностное копирование из нескольких обьектов 
   Object.assign({}, user, {age:30}, {id:123, reg: true}); копирует справа налево перезаписывая посторяющие свойства и в итоге записывает все в новый обьект. (user-еще обьект)  

console.log(user1 instanceof User) - проверяет действительно ли данный обьект user1 создан конструктором User 


------------------------------------------------------
ООП
абстракция - нет в JS(нет интерфейсов, абстрактных классов)
полиморфизм - есть в каком-то виде, в дргуих языках в функцию можем передать ТОЛЬКО заранее прописаный класс. В JS передаем что угодно, но если надо прописать что-то конкретное то используем интерфейсов
наследование - способность обьекта или класса базированися на другом обьекте или классе для переиспользования кода
        прототипное в JS
        прототип - обьект используемый для расширения возможночтей. 
        если ничео нет в самом обьекте jS, то идет в прототип
инкапсуляция - когда в одну переменную кладется несколько значений. обьединение подобных данных
        сокрытие 

если js не находит данные в обьекте, лезет в прототип и обьект расширяется
поиск свойства идет с обьекта и потом по прототипам и прототипам прототипа. последний прототип: null
получить прототип (обьект, который расширяет обьект):
    obj.__proto__
    Object.getPrototypeOf(obj);
Object.create(null) - создать обьект без прототипа 

DTO - data transfer object - бьект который просто передает данные и содержит цифры и строки

console.log(obj.__proto__); посмотреть прототип (ES6)
console.log(Object.getPrototypeOF(obj)); посмотреть прототип es5 



Старый способ функциональное ООП:
const myCar = {
    model: 'BMW',
    beep: function (){
        console.log("машина подает сигнал")
    } //умтаревшая запись
beep(){
    console.log(`${this.model} подает сигнал`) this - контект, вызывает то, что было слева от точки в момент вызова метода
} // МЕТОД записываем так по стандарту ES6
}
myCar.beep();

++++++
ES5

function Car(model){ //с большой буквы - вызываются через new 
    this.model = model;
}
ДОбавление метода в прототип, на основе которого создаются все машины
Car.prototype.beep = function(){
    console.log(`${this.model} подает сигнал`);
}
const car1 = new Car('BMW');
car1.beep();
+++++++++++++++++++++++++++

function Person(name, gender){
    this.name=name;
    this.gender = gender;
}
function Employee(name, gender, position){
    Person.call(this, name, gender);
    this.position = position;
}
Employee.prototype = Object.create(Person.prototype); - добавляем работнику НОВЫЙ обьект с прототипом человека, где методы человека
Employee.prototype.constructor = Employee; - конструктор добавляется в прототип, в принципе не нужен, но правило хорошего тона добавлять

НОВЫЙ СПОСОБ классы ES6 (EcmaScript2015):

class Person {
    constructor(name, gender){
        this.name = name;
        this.gender = gender;
    }
    sayName(){
        console.log(`Мое имя: ${this.name}`);
    }
}
class Employee extends Person{
    constructor(name, gender, position){
        super(name, gender);
        this.position = position;
    }
    sayPosition(){
        console.log(`Моя должность: ${this.position}`);
    }
}

------------------------------------------------------------------------
Браузерное событие 
onclick="alert('Товар добавлен в корзину');"



------------------------------------------------------------------------
"use strict" - строгий режим JS

prompt('Введите число', default)
alert(вывести в модальное окно)
console.log();
Округление:
    Math.round() по правилам математики
    MAth.floor() вниз 
    Math.ceil() вверх 
    Math.trunc() просто откидывает дробную часть
    число.toFixed(2) - обрезает чсло с 2 знаками после точки и возвращает строку
Number()
String()
Boolean()
parseInt('434343fdfdf') //получим 434343. не работаетесли число в конце
number.toFixed(4) // обрезает число на 4 знаках после запятой, но возвращает строку 

console.trace() - показывает в консоли какие вызовы каких функций были до строки с этой командой



трепачев задачи js 