bJS - язык программирования, добавляет интерактив на страницу и взаимодействие с пользователем 
БЕЗ СТРОГОЙ ТИПИЗАЦИИ

программы, содержащие движок для выполнения JS:
веб-браузер+
Среды выполнения:
    Node.js (бэкекнд - серверное программирование) серверые возможности с Ubuntu
    Deno
    Electron + windows
Другое ПО где есть интерпритатор или компилятор JS кода 

Стандарты JS - ECMA International выработали ES5 в 2015 году и далее ES6 и далее 
---------------------------------------------
Переменные и области видимости 
let изменяемое значение
const - значение изменит нельзя - пишем капсом
var - старый способ, проблемы с областями видисосFти (не использовать! устаревший стандарт) - видна везде, ограничивается ТОЛЬУО блоком функции
Область видимости - участок кода, короты может обратииться к переменной и получить из мее значение
    локальная переменная
    глобальная переменная
ОБЛАСТИ ВИДИМОСТИ - 
1. блочная ОВ
2. ОВ функции 
3. ОВ модуля 
4. глобальная ОВ 
5. лексическая ОВ 

Var может всплыть где угодно, для нее не существует областей видимости кроме боока функции. можно обьявить в конце кода, использовать в начале. с let const так не получится

if (3 > 1 ){ let a =5;} 
console.log(a) // error a is not defined - a создается let только в if 
if (3 > 1 ){ var b =5;} 
console.log(b) // 5 var создает везде

${переменная}
ОБратными кавычками
`вывести в консоль строку переменную: ${переменная} `
$_ спецсимволы в переменных разрешены
\n символ переноса строки
\ простой перенос строки в редакторе

Всплытие переменной(поднятие, hoisting) - механизм в js, в котором переменные и функции обьявленные как function declaration передвигаются вверх своей области видимостиперед тем как код будет выполнен 
    присвоение значений переменным юудет в тах же местах в коде, где они и были написаны
   - переменная обьявленная через var. обьявление всплывает, но присвоение остается на месте
   - let не всплывает как var 
   - в теле функции всплытие ограничивается телом функции (поэтому var ограничивается только функцией в плане глобальной зоны видимости )

---------------------------------------------------------------------
Подключить можно в HEAD (но нельзя). 
страница грузится сверху вниз, поэтому скрипт пишем в самом внизу перед закрывающим </body>:
   1. <script>
        let countButton = 0;
    </script>
    2.<script src="main.js"></script> - старый способ
    3. в теге head: грузятся параллельно с построением страницы
        <script async src="main1.js"></script> запустится когда загрухится, (плох потому что не знаешь когда загрузится и выполнится)
        <script defer src="main2.js"></script> запустится только тогда когда все теги созданным В ПРИОРИТЕТЕ
---------------------------------------------------------------------
ТИПЫ данных
string строка
number число
    NaN - (не число при ошибке вычисилений), арифметически ничего не сделать ("привет" * 10 = NaN)
    Infinity, -Infinity бесконечность - деление на 0 и на -0
boolean булево значение
undefined - спец тип данных - присваивается вновь созданным, но не инициализированным переменным 
object обьект - хранит набор данных, к полям(свойствам) обращается через . или ключ в квадратных скобках
    array - упорядочный список элементов
    function 
null - спец значение, используется в основном с обьектами, что в переменной нет обьекта 
symbol - новый тип данных, создает уникальные ключи для свойст обьектов
BigInt большое число больше 2**53 - для сложных расчетов, в конце литера n 

typeof переменная - тип данных 
typeof null = object - баг
 
Перевод строки в число:
+srt унарный плюс получим Nan если не число или число с буквами
Number(str) функция конструктор для чисел
Number.parseInt(str) собирает число из строки посимвольно (str=64.3regb5) получим 64
Number.parseFloat(str) получим 64.3

контеканация:
если есть хоть одна строка с +, то это контеканация
если слева и справа число, то это сложение

------------------------------------------------------------------------
switch()
case
default

тернарный оператор ? для легких if
console.log(
    goodCount > 0 ? 'в корзине есть товары' : 'корзина пуста'
);

?? оператор нулевого присваивания
    пример
    let x;
    let y = x && 10; если x пустой то присваивается 10. если не пустой, то присваивается x 

?. - оператор опциональнй последовательности:
    цепочка вызовов:    obj.key1?.value - если есть свойство key?  взять его значение,если нет, то undefined


----------------------------------------------------------------
ЦИКЛЫ 
повторяемое действие до наступление каких-то условий
1.инициализация переменных в начале цикла
2.проверка условия выхода на каждой итерации (до или после)
3. исполнение тела цикла на каждой итерации
4. обновление счетчика итерации

while(условие){тело}

do {
}while(условие)

for(let i=0; i<count; i++){}


for(const i in ...) переберет ключи 
for(const val of ...) переберет знаения в массиве(итера)
arr.forEach(функция) - выполняет функцию для каждого элемента 
arr.forEach((value, index, arr) => {тело стрелочной функции});



-------------------------------------------------------------------------
ФУНКЦИИ

function sayPrice(){
} после стандартного обьявления функции не стявятся ; - видна везде, обьявляется внизу function declaration
const fun2 = function (){}; вызывается только после обявляения function expression ставятся ;
Стрелочные функции:
const fn3 = () => {
    console.log(123);
};
const fn3 = () => console.log(123);

 
именнованные(присваивается имя) декларативный подход - обьявление через function nameFunc(параметры) 
анонимные function(праметр)

функциональное выражение const getMax = (numbers) => {}

стрелочные - возвращают значение
если 1 значение то скобки можно урбать let foo = number => { return number + 1;}
если совсем нет параметров ставятся скобки let foo = () => {}
если 1 действие, фигурные скобки и return можно убрать lef foo = number => number +1;
параметр по умолчанию let foo = (param = 5) => {}
если действие одно, {} не ставятся, но автоматом значит появляется return
если фигурные скобки стоят, return не ставится автоматом 
НЕ ПРИНИМАЮТ другой контекст this, который запоминает при создании, не работают методы call,bind 

стандартные функции запоминают this в момент вызова, что слева от точки(user.func())
стрелочные запоминают this в момент создания 



параметр - при создании функции
аргумент - передаем функции 

старый вариант const foo = function(a, b) {return a+b}
новый const foo = (a, b) => a + b;

области видимости
    локальная 
    глобальная

если переменная обьявлена без ключевого слова, она в глобальной области видимости. даже если в теле функции. область видимости windows
если переменная обьявлена с let то область видимости не window, a scriptSEO or Search Engine Optimization is the technique used to optimize your website for better rankings on search engines such as Google, Bing etc.


если передается в функцию аргументов больше, чем задумано
function hello(name, ...other){
    console.log('hello' + name);
    console.log(other); \\ other это массив переданных аргументов
}

let num=5;
function f(num){ // у функции создается СВОЯ переменная num, в нее копируется значение 5.
    num=10 // у локальной переменной значение становится 10, при завершении функции она стирается
}
console.log(num) // 5. т.к. переменная не изменилась

const obj = {num=5}; //создается обьект, ССЫЛКА на него записывается в переменную obj
function f(obj){ //в функцию передается ССЫЛКА на обьект (обьекты так не копируются, копируются только ссылки на ячейку памяти с обьектом)
    obj.num=10; //по ссылке ИЗМЕНЯЕТСЯ свойство в обьекте
}
console.log(obj) // 10, при завершении функции свойство ИЗМЕНЕНО

let a = func; записывает ссылку на функцию, тогда а можно тоже запустить  как функцию: а()
let a= func(); - записываем результат выполнения функции 


чистые функции - такие функции, которые при вызове с одними и теми же переметрами всегда возвращают одинаковое значение, при этом взаимодействуют только с полуеннысм аргументами, без глобальных переменных 
Лесический контекст - механизм, позволяющий функции во время ее вызова получить доступ к переменным, константам и всему что ей нужно.
Если много завыканий, создается много лексических значений и это наз. утечкой памяти 
Иммутабельность - нельзя изменять предыдущие данные, надо создавать новые пр изменении
arguments - переменная доступна внутри всех функций, это все переданные параметры. являеься псевдомассивом

func.call(obj[, key, key]) - запуск функции с каким то обьектом (контекстом)
func.apply(obj [, [key, key]]) аналог call, дополнительные параметры в массиве 
    пример:
    function showName(){console.log(this);}
    const user1 = { name: 'Ann'};
    const user2 = { name: 'Nna'};
    showName.call(user1) - вызов функции от обьекта 
func.bind(obj) - создает новую функцию и внутри вызывает функцию в контексте конкретного обьекта 
    const fn = showName.bind(user1);
    fn();

setTimeout(()=> {}, 1000) - откладывается выполнение функции. возвращает id, по нему можно удалить
clearTimeout(id)
setInterval(()=>{}, 1000) - повтор действия каждые 10000мс 
clearInterval(id)
если вызывать эти функции с функцией с this, будет вызываться с обьектом windows. Можно передать функцию с bind и конкретным контекстом 

IIFE - функции, которые немедленно выполняются:
(function() {
    код
})(); используются для деления кода на блоки, чтобы переменные не пересекалисью сейчас это делают модулями
чтобы поделиться переменной из одной такой функции в другую используют window.переменная 

ЗАмыкание - способность функции запоминать при создании свою область видимости и обращаться к ней в любой части приложения


запирать переменную внутри функции и не дает удалить акую-то ее переменную , когда функция использует внешнюю пременную 
    function getNameRep(){
        const name = 'john'; //переменная остается в памяти, потому что функция showNamе(); может быть вызвана
        function sayName(){
            console.log(name); внутри функции используется внешняя переменная 
        }
        return sayName;
    }
    const showName = getNameRep(); //
    showNamе();

this - указание на контекст 
дефолтный контекст - window, усли строгий режим - то undefined
вызов с контекстом обладателя user.foo()
потеря котекста foo2(user.foo) или foo2 = user.foo;
----------------------------------------------------------------------------------
Приведение типов:
Дают false:
""
0. -0, Nan
null, undefined
false

Инкремент - увеличение операнда на установленный фиксированный шаг а++
Декремент - уменьшение операнда на установленный фиксированный шаг а--
контеканация - сложение строк 
------------------------------------------------------
МАССИВЫ
упорядоченный список элементов 
при простом копировании массива в впеременную, копируется ССЫЛКА на масси, те изменение второй переменной влечет изменение исходного массива 
const array = [];

Перечислимые/неперечислимые свойства используемые при итерировании массива или обьекта 
    length - при итерировании не появляется
console.log(arr.propertyIsEnumerable('length')) - узнаем является ли перечислимым свойство //false 

forOF:
for(let value of array){
    console.log(value)//перебор значений массива
}

array.push(элемент); добавить в конец массива и возвращает новую длину массива
array.pop() - удаляет и возвращает последний элемент
string.split('разделитель') - разбивает строку и записывает в массив 
array.join('разделитель') - склеивает массив в строку с нужным разделителем 
array.slice() - возвращает полную копию массива, не ссылку
array.slice(0,2) - копирует с 0 индекса до 2(не включая) 
array.splice(с какого индекса удалить [, сколько элементов удалить, что добавить, ...]) удаляет сколько хочешь элементов и заменяет на другиею возвращает удаленные
array.indexOf(значение) - возвращает true или false если есть такое значение 
array.shift() - удаляет первый элемент из массива и возвращает его значение, изменяет длину массива 
array.unshift() - добавляет элемент в начало и возвращает новую длину массива
array.filter(функция фильтра - коллбек функция возвращает true/false) - записывает значения, которым вернулось true 
array.find() - возвращает значение первого найденного в массиве элемента, удовлетворяющего условию callback функции или возращает undefined
       const lessThan50 = prices.filter(function(element){ return element < 50};) - приходит каждый элемент в колбек функцию 
array.includes(значение) определяет содержит ли массив определенный элемент, возвращая true-false 
array.map(function) - метод применяет к каждому элементу функцию и формирует новый массив
        const numsPlus10 = nums.map(function(num){return num +10});
array.reduce(function) - применяет функцию к каждому элементу массива (слева-направо), возвращая одно результирующее значение.
array.sort() -  на месте сортирует массив и модифицирует исходный. по умолчанию - по юникоду
    array.sort([compareFunction])
    function compare(a,b){
        if(a<b по некоторому критирию сортировки) return -1;
        if(a>b...)return 1;
        return 0; //усли равны 
    }
array.from(данные) - превращение коллекции в массив 
...array - оператор spread, разбивает массив на отдельные элементы 
...rest - оператор rest- позволяет собрать аргументы функции в массив 
    function fn(...rest){//rest это массив переданных в функцию значений }


можно использовать опциональную цепочку (optional chaining) product.photos?.length, чтобы проверить наличие свойства photos и его длину.





------------------------------------------------------
ОБЪЕКТЫ

o1 ={}; в переменную записывается ссылка на ячейку памяти где хранится обьект 
o2 ={}; уже другая ссылка
o1 === o2; false - ссылки на 2 обьекта не равны
если куда то передаем обьект, то передаем на сам обьект, а его ссылку

const car={
    model: "Audi",
    year: 2023,
    count: 2;
    buy: function(){
        if(this.count>0){
            console.log('Вы купили товар')
        } else {
            console.log('Недостаточно товара')
        }
    }
};
console.log(car.model);
car.power=350;
car.buy();


console.log(Object.getOwnPropertyNames(array)) - показывает список собственных свойств, не прототипа 

forIn:
for (let property in obj){
    console.log(property) //вывод ключей(имя свойств)
}
for (let property in obj){
    console.log(obj[property]) //вывод значений
}

delete car.year; удалить
Object.keys(obj) - вернет все ключи в массиве
Object.values(obj) - вернет все значения в массиве
Object.entries(obj) - вернет пары ключ-значение в массиве

Object.assign() - поверхностное копирование из нескольких обьектов 
   Object.assign({}, user, {age:30}, {id:123, reg: true}); копирует справа налево перезаписывая посторяющие свойства и в итоге записывает все в новый обьект. (user-еще обьект)  

console.log(user1 instanceof User) - проверяет действительно ли данный обьект user1 создан конструктором User 

ГЛОБАЛЬНЫЙ ОБЪЕКТ:
    window в браузере 
    Global в Node.js
    WorkerGlobalScope в воркере 

работа с МАССИВОМ обьектов и функции высшего порядка
    map
    filter
    reduce - выводит какое то общее значение для массива(например серднее или сумма какого-то свойства )
    some - проверяет есть ли хоть один элемент, удовлетворяющий условию функции колбека 
    find 

ДЕСТРУКТУРИЗАЦИЯ
cinst cstudent = {
    firstname: 'ddd';
    lastName: 'dd';
    age:3;
}
const { firstName, lastName, age } = student; создаются переменные с именами firstName,lastName, age и значениями свойств обьекта 
// Деструктуризация - мы
объявляем все переменные в фигурных скобках, название должно совпадать с
нужным нам параметром.

или
    let a=5, b=100;
    [a, b] = [b, a]; // в а будет лежать 100 и в b 5





------------------------------------------------------
ООП
абстракция - нет в JS(нет интерфейсов, абстрактных классов)
полиморфизм - есть в каком-то виде, в дргуих языках в функцию можем передать ТОЛЬКО заранее прописаный класс. В JS передаем что угодно, но если надо прописать что-то конкретное то используем интерфейсов
наследование - способность обьекта или класса базированися на другом обьекте или классе для переиспользования кода
        прототипное в JS
        прототип - обьект используемый для расширения возможночтей. 
        если ничео нет в самом обьекте jS, то идет в прототип
инкапсуляция - когда в одну переменную кладется несколько значений. обьединение подобных данных
        сокрытие 

если js не находит данные в обьекте, лезет в прототип и обьект расширяется
поиск свойства идет с обьекта и потом по прототипам и прототипам прототипа. последний прототип: null
получить прототип (обьект, который расширяет обьект):
    obj.__proto__
    Object.getPrototypeOf(obj);
Object.create(null) - создать обьект без прототипа 

DTO - data transfer object - бьект который просто передает данные и содержит цифры и строки

console.log(obj.__proto__); посмотреть прототип (ES6)
console.log(Object.getPrototypeOF(obj)); посмотреть прототип es5 



Старый способ функциональное ООП:
const myCar = {
    model: 'BMW',
    beep: function (){
        console.log("машина подает сигнал")
    } //умтаревшая запись
beep(){
    console.log(`${this.model} подает сигнал`) this - контект, вызывает то, что было слева от точки в момент вызова метода
} // МЕТОД записываем так по стандарту ES6
}
myCar.beep();

++++++
ES5

function Car(model){ //с большой буквы - вызываются через new 
    this.model = model;
}
ДОбавление метода в прототип, на основе которого создаются все машины
Car.prototype.beep = function(){
    console.log(`${this.model} подает сигнал`);
}
const car1 = new Car('BMW');
car1.beep();
+++++++++++++++++++++++++++

function Person(name, gender){
    this.name=name;
    this.gender = gender;
}
function Employee(name, gender, position){
    Person.call(this, name, gender);
    this.position = position;
}
Employee.prototype = Object.create(Person.prototype); - добавляем работнику НОВЫЙ обьект с прототипом человека, где методы человека
Employee.prototype.constructor = Employee; - конструктор добавляется в прототип, в принципе не нужен, но правило хорошего тона добавлять

НОВЫЙ СПОСОБ классы ES6 (EcmaScript2015):

классы в себе по умолчанию содержат use strict 
class Person {
    constructor(name, gender){
        this.name = name;
        this.gender = gender;
    }
    sayName(){ //если пишем так то функция попадает в прототип 
        console.log(`Мое имя: ${this.name}`);
    }
    foo = function (){.........} //так функция попадает в экщемпляр 
}
class Employee extends Person{
    constructor(name, gender, position){
        super(name, gender);
        this.position = position;
    }
    sayPosition(){
        console.log(`Моя должность: ${this.position}`);
    }
}


------------------------------------------------------------------
обьектрая Модель документа DOM
набор обьектов.
для созданного тега создает специальный обьект, с его помощью можно управлять тегом 
window - глобальная переменная
document - обьект ДОМ хранятся все обьекты, отвечающие за теги на страницы
console.dir(document) - смотрим не как на верстку, а как на обьект 

Старые:
document.getElementById() - найти элемент по id 
document.getElementByClassName() - найти элемент по классу. если несоклько элементом, то возвращает коллекцию - динамическая, при добавлении элемента добавляется элемент без обновления 
document.getElementByTagName() - по тегу 

Новые:
document.querySelector('.any-class') - находит ПЕРВЫЙ попавшийся тег с таким селектором или undefined
document.querySelector('.any-class:last-child') - находит последний тег 
document.querySelectorAll('p:nth-child(even)') - кождый четный тег р (возращает nodeList статическая, не обновляется при добавлении элемента)
document.body; - <body>
document.documentElement; - <HTML>
document.images; все рисунки
document.links; все ссылки
document.head; <head>
document.title; <title>
document.forms;

Еlement - элемент тег, наследуется от ноды, есть все методы ноды 
Node - узел: тег, текст, перенос строки 

firstDiv.querySelector() можно искать не во всем документе, а в найденном диве 

firstDiv.innerText; получить видимый текст 
    firstDiv.innerText = 'новый текст'; - заменить текст 
firstDiv.innerContent; получить весь текст 
firstDiv.innerHTML; разметка
    firstDiv.innerHTML = <h1>ПРивет</h1>; - превращает строку в тег и вставляет 

const h2El = document.createElement('h2') - создает тег, пока не добавишь, не увидишь
firstDiv.appendChild(h2El); - добавляет созданный тег в див ребенком.
    если найдем элемент на странице и добавим его ребенком в другой тег, он перетащится
    на основе найденного тега делаем клон и копируем:
    const h2Clone = h2El.cloneNode(true); - true - глубокое копирование
firstDiv.remove() - удалить 

button.insertAdjacentHTML('afterbegin', '<u>ПРивет</u>'); - вставить элемент перед тегом. (строку превращает в теги и вставляет)
    есть 4 положения:
    beforebegin
    afterbegin
    beforeend
    afterend

    ПРИМЕР:
    const prodName = 'Prod 1';
    const prodImgUrl = 'https://picsum.photos/200/300';
    const prodPrice = 123;

    const prodMarkup = `
        <div>${prodName}</div>
        <img src="${prodImgUrl}" alt="photo">
        <div class="price">${prodPrice}</div>
    `;
    const div = document.querySelector('div');
    div.insertAdjacentHTML('beforeend', prodMarkup);

button.insertAdjacentElement('afterbegin', firstDiv); - вставляет готовый тег

firstDiv.append(); добавляет в конец ноды
firstDiv.prepend(); добавляет в начало ноды
firstDiv.before(); добавляет до ноды
firstDiv.after(); добавляет после ноды
firstDiv.replaceWiht('pfpfpf'); заменяет найденный div на текст 

firstDiv.className - просмотреть все классы, 
    firstDiv.className = 'заменить классы '

firstDiv.classList - просмотреть классы и удобно с ними работать 
    firstDiv.classList.add('name')
    firstDiv.classList.remove('name')
    firstDiv.classList.toggle('name') если есть удалит, если нет - добавить
    firstDiv.classList.contains('name') есть ли данный класс 

firstDiv.id = 'ddddd' - найти id  и заменить

let el = document.querySelector('[aria-labelledby="dropdownMenuButton"]); поиск по атрибуту 
firstDiv.src = 'ddddd';
firstDiv.disabled = true;
firstDiv.getAttribute('nameattrib') - получить значение атрибута 
firstDiv.setAttribute('nameattrib', 'new') - заментить значение аттрибута 
firstDiv.setAttribute('newAt', 'new') создать новый атрибут 
element.removeAttribute("type"); удалить аттрибут 
firstDiv.attributes - получить список всех атрибутов 

        data-njnjnjn - свой личный кастомный атрибут начинается с data-
firstDiv.dataSet - содержит все дата атрибуты 
firstDiv.dataSet.hi = 'првиет' новый атрибут 
delete firstDiv.dataSet.hi - удалить атрибут 

firstDiv.style - все стили ВНУТРИ тега 
firstDiv.style.backgroundColor = "red" - изменение стилей
getComputedStyle(firstDiv) - покажет все стили 
----------------------------------------------------------------
СОБЫТИЯ 

самый плохой способ:(тк смешивает в одно html и js)
onclick="alert('Товар добавлен в корзину');" - аттрибут элемента запускает функцию

способ лучше: при клике js проверяет есть ли событые при клике и выполняет. если событий несколько, выполнится последняя
const btnEl = document.querySelector('button');
btnEl.onclick = function(){
    alert('Товар добавлен в корзину');
};

нормальный вариант: добавить событе слушателя 
const btnEl = document.querySelector('button');
btnEl.addEventListener('click', () => {alert('Товар добавлен в корзину');});
btnEl.addEventListener('click', () => {alert('спасибо!');}); несколько функций
btnEl.addEventListener('click', event => {cjnsole.log(event.tatget);}); инфа о событии

btnEl.removeEventListener('click', () => {alert('Товар добавлен в корзину');}); удалить обработчик. тогда функция должна лежать в переменной!!
        setTimeout(()=>{console.log(1);}, 1000) - отложит выпрлнение функции на 1000ms. 
        в обработчикек событие срабатывает сразу, а функцию можно отложить 

event.target.tagName !== "BUTTON" - тег на который нажали
event.target.textContent - текст нажатого тега


События мыши:
    click – происходит, когда кликнули на элемент левой кнопкой мыши (на устройствах с сенсорными экранами оно происходит при касании).
    contextmenu – происходит, когда кликнули на элемент правой кнопкой мыши.
    mouseover / mouseout – когда мышь наводится на / покидает элемент.
    mousedown / mouseup – когда нажали / отжали кнопку мыши на элементе.
    mousemove – при движении мыши.
События на элементах управления:
    submit – пользователь отправил форму <form>, вешается на ФОРМУ 
    focus – пользователь фокусируется на элементе, например нажимает на <input>.
    blur - когда спадает фокус 
Клавиатурные события:
    keydown и keyup – когда пользователь нажимает / отпускает клавишу.
События документа:
    DOMContentLoaded – когда HTML загружен и обработан, DOM документа полностью построен и доступен.
CSS events:
    transitionend – когда CSS-анимация завершена.
Сщбытия:
     copy - document.getSelection().toString() - берем в буЕР ЧТО СКОПИРОВАНО, надо отменять действие по умолчанию 
    resize - весшаем на window - изменение размера экрана, должен быть meta viewport
    change - изменение и сменили фокус, вешают на input
    input - каждое изменение ввода в input, select 
    scroll - промотка, вешается на window сколько промотали с верха страницы. функция должна быть максимально простая 

document.addEventListener("DOMContentLoaded",  console.log("все теги прогрузились")
      );
window.addEventListener("load", console.log("страница загрузилась"));
-------------------------------------------------------------------------------------
ВСПЛЫТИЕ СОБЫТИЙ 
собитие идет имеено от того на котором кликнули и распространяется дальше на родителей
перед этим погружается от родителя window-document-html-body-div-section-p 
а когда кликнули на элементе всплывает в обратном порядке 
    element.addEventListener('click', anyFunction, [true]) по умолчанию стоит false на всплытие, а true обоззначает ловлю собития при поглужении
event - само событие.
фунция принимает параметр event - свойство target показывает куда кликнули 

elem.addEventListener('click', event => console.log(event.target.textContent))
или 
elem.addEventListener('click', ({target}) => console.log(target.textContent)) - деструктуризация

event.target.tagname - именно тот тег на который кликнули(произошло событие), не меняется
this.tagname - элемент, который обрабатывается сейчас. при всплытии события может меняться

события все всплывают, кроме focus 
event.stopPropagation(); - свойство, которое запрещает всплытие. прописываем в начале тела функции 
event.stopImmediatePropagation(); - запрет вообще последующих событий, даже прописаных следующих функций 

event.preventDefault() - отмена действия браузера по умолчанию 

element.addEventListener('click', anyFunction)ж - переменная с сыллкой на функцию БЕЗ круглых скобок, т.к.ее не надо сразу выполянть 

если повесить событие на родительский элемент, то можно поймать клик на дочернем (наз. ДЕЛЕГИРОВАНИЕ)
if(event.target.tagName !== 'BUTTON') {return}
else{действие }

выделить элемент, в console набрать $0 и смотрим методы и информацию 

---------------------------------------------------------------------
РЕГУЛЯРНЫ ВЫРАЖЕНИЯ мощний инструмент для поиска и замены строк
истанс класс new RegExp('string')
можем проверять есть ли вхождения регулярки в строку:
const regStr = new RegExp('string');
const reg2 = \word\flag
regStr.test('строка для проверки', flag)
flag - 'g' - ищет глобально вхождения в строку 
    - 'i' - не стомтит на регистр 
 в строках и массивах есть методы, которые принимают регулярные выражения например str.match(reg) - возвращает массив найденных результатов
 str.replace(reg, 'значение для замены') - все вхождения регулярки заменяют на введенную строку 

\/d\ все числа
/.D\ все не числа 





------------------------------------------------------------------------
"use strict" - строгий режим JS

prompt('Введите число', default)
alert(вывести в модальное окно)
console.log();
Округление:
    Math.round() по правилам математики
    MAth.floor() вниз 
    Math.ceil() вверх 
    Math.trunc() просто откидывает дробную часть
    число.toFixed(2) - обрезает чсло с 2 знаками после точки и возвращает строку
Number()
String()
Boolean()
parseInt('434343fdfdf') //получим 434343. не работаетесли число в конце
number.toFixed(4) // обрезает число на 4 знаках после запятой, но возвращает строку 

console.trace() - показывает в консоли какие вызовы каких функций были до строки с этой командой


learn.javascript.css-selectors 
трепачев задачи js 
---------------------------------------------------------------------------------------------
ES6:
можно создать блок { } - область видимости 


деструктуризация Объекта const {name} = obj;
                const {name, age, ...rest} = obj;
                const {name: myName, age, ...rest} = obj; переименновываем переменную в MyName
                const{name: {id}} = ogj; вложенная деструктуризация усли name обьект и в нем свойство id 
операторы spred и rest
деструктуризация массива const [a, b, c] = array        
                        const [a, , c] = array;
шаблонные строки - const str = `текст ${a}`
стрелочные функции - работают с контекстом 
дефолтные арументы - const foo(a,b=0){}
------------------------------------------------------------------------------------
AJAX - позволяет перерисовать страницу без перезагрузки полностьб. при переходе на другую страницу мы получаем не новую страницу, а данные для перерисовкию делается все асинхронно 
-технологии для работы AJAX: HTTP - протокол передачи гипертекста, для передачи данных 

-JSON и XML
-браузерное API - XMLHttpRequest (старое апи), Promises, Fetch 

HTTP  - протокол передачи гипертекста(html) - 
должны быть 2 цчастника передачи - клиент(браузер, сервер и тд) и сервер
всегда есть кто запрашивает и отвечает
запросы на получение данных, на изменение данных, всегда должен быть ответ

HTTP запрос (и тело тоже) делится на 3 части:
стартовая строка - метод запроса, протокол, доменное имя 
заголовки
тело 

стартовая строка ответа - протокол, код статус ответа, короткое сообщение 

методы запросаЖ 
GET получение данных от сервера. у запроса тело нет и поэтому данные запрашиваются с помощью адреса и параметров в строке адреса
POST - получение данных от сервера, например при вводе пароля, который не надо показывать в адресе строки. чаще отправляют формы, сервер возвращает данные, чаще это результат сохранения данных на сервере
PUT что-то изменить
PATCH что-то изменить
DELETE удалить на сервере 

Формат данных JSON 
-все ключи JSON обьекта взяты в кавычки 
-ключи только примитивы, массив или обьектю функций быть не может 
- не допускаются комментарии
-в конце каждой группы клчей или элементов массивов нельзя ставить запятую 

JSON.stringify({name:'test'}); - метод форматирует JS объект в строку в JSON формат 
JSON.parse('{"name":"test"}') - метод строку JSON превращает в обьект JS
undefined в обьекте игнорируется, в массиве превращается в null

mocky.io - заглушка вместо сервера, пересылает заданные ответы сервера по ссылке
-----------------------------------
работа с xmlHttpRequest: 
асинхронно получили данные для страницы без перезагрузки 
const URL = "https://run.mocky.io/v3/hfkjdhfkjdhkfjshkfsjhkfsj"
const xmlHttpRequestATemplate_1 = () => {
    const xhr = new XMLHttpRequest();
    xhr.open('GET', URL); // настройка метода ope
    const loadHandler = () => {
        console.log(JSON.parse(xhr.response)); // функция обработчик, которая парсит JSON.parse ответ xhr.response, можно создат в любом месте и задать в свойства onload 
    }
    xhr.onload = loadHandler; //устанавливаем функцию обработчик, которая запустится только при получении ОТВЕТА от сервера 
    xhr.send(); // метод активирует запрос, асинхронный запрос на сервер если метод post, то xhr.send(данные для сервера);
}
xmlHttpRequestATemplate_1();

есть синронный код и асинхронный код (который берется из event loop)
любые обращения к серверу - асинхронные 
в event loop код попадает из событий или set timeout и setTimeout
сначала выпоняется синхронный код, потом код из event loop 

const prom = new Promise((resolve, reject) => { //без функций состояние pending(по умолчанию)
    resolve() //переводит в состояние fulfilled запускается при успешном выполнении
    //reject //переводит в состояние rejected обычно запускается при ошибке 
})
если вдруг произошла ошибка, она прилетает в rejected и попадает в параметр метода catch 

состояния из pending переключаютс в  fulfilled rejected только 1 раз 
prom.then(()=>{ выполнится при состоянии fulfilled
    ...
})
prom.catch(()=>{ выполнится при состоянии rejected
    ...
})
ПРИМЕР
const service = function(){
    return new Promise((resolve)=>{ // создаем новый промис, куда через 2 сек приходят данные 
        setTimeout(()=>{
            resolve('data); /// 
        }, 2000)
    })
}
service().then((data) = { // когда пришли успешно данные запускается функция 
    console.log(data)
});

из then можно что-то вернуть и получить в следующем зене:
const prom = new Promise((resolve)=>{
    resolve('test') //передаем в следующий then - 'test'
})
const prom2 = prom.then((data) =>{
    console.log(data); //выведется test, мщжем отсюда вернуть еще что-то и получить его в следующем then
    return 110000
})
const prom3 = prom2.then((data)=>{
    return new Promise((resolve)=>{ //возвращаем новый промис 
resolve('new promise')
    })
})
Аналогично цепочкой:
    const prom = new Promise((resolve)=>{
        resolve('test')
    }).then((data) => {
        return data; 
    }).then((data)=>{
        return new Promise((resolve)=>{
            resolve('new promise');
        })
    }) - можно возвращать значение и пользоваться им дальше, можно вернуть RESOLVE нового промиса, а не сам промис 

-----------------------------------
Fetch

const prom = fetch(URL);
prom.then((res)=>{
    consr header = res.headers.get('Content-type'); //получить заголовок и его тип
    const result = res.json()// возвращает промис, для получения его результата вызываем зен 
})
prom.then((res)=>{
    return res.json()
}).then((data)=>console.log('вывести полученые данные '))

пример:
fetch(url)
    .then((response)=>response.json()) - получаем ответ от сервера и получаем данные 
    .then((data) => console.log(data)) - можем с данными что-то делать 
    .catch((error) => console.log("Что-то пошло не так ")); обработка ошибки 

заготовка для получения данных:
const getData = (url) => //избавляемся от ожидания ответа от сервера в дальнейшей работе 
    new Promise((resolve, reject)=>{
        fetch(url)
            .then((response)=>response.json()) //когда дождались ответа от сервера, берем в этом ответе json
            .then(data => resolve(data)) //завершение работы промиса 
            .catch((error) => reject(error))
    });
getData(url)
    .then(data => console.log(data))
    .catch(error => console.log('что-то пошло не так'));
-------------------------------------
ASINC/AWAIT

const getData2 = async (url) => { //создаем асинхронную функцию 
    const response = await fetch(url); //ждем когда выполнится fetch и получим ответ от сервера, который помещается в response
    const data = await response.json(); //ждем когда из ответа сервера получим json и запишем его в дату 
    return data;
};
try {
const users = await getData2(url); //ждем выполнения функции 
console.log(users);
} catch(error) {
console.log('что-то пошло не так')
}

------------------------------------
localStorage - локальное хранилище браузера, очищается только при принуительной очистке. при закрытии браузера и вкладки не удаляется
localStorage.clear - щчищение
.getItem(key) - получить пару ключ значение 
.setItem(key, item) - добавить 
.removeItem(key) удаление 
.key(индекс) выводит ключ по индексу 
localStorage.user = JSON.stringify({name: 'ann'});
const newUser JSON.parse(localStorage.user)
--------------------------
Import Export

при подключении скрипта пишем type='module'
при создании модуля в конце файла пишем export default fileName
в файле скрипта import file from './фдрес file.js'

export function def(){}
import {def} from './...' если импортируем функцию или переменую, то нужны {}, через запятую перечисляется что берем (типа записи деструктуризации)

export default {func1, func2}; 
import calc from       и тошда можно вызывать функции как методы, так как calc это обьект calc.func1 calc.func2 


----------------------------------
полезные библиотеки подключаются скрипты в тело странички
https://github.com/hsnaydd/moveTo для плавного перемещения на якорную ссылку 
https://lodash.com/ расширенные математические функции 
https://atomiks.github.io/tippyjs/ высвечивается красивая подсказка при наведении на любой элемент 
https://swiperjs.com/ - слайдеры и пагинации 
https://github.com/aFarkas/lazysizes делает загрузку медиафайлов, которые пока не видимы постепенной
https://imask.js.org/ работает с инпутами
https://animejs.com/ разные анимации

https://jsonplaceholder.typicode.com/ апи для теста
axios библиотека для работы с асинхроном  